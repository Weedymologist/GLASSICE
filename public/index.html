<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GlassICE // Interactive Chronicle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Define CSS Variables for theming */
        :root {
            --bg-color: #02040a;
            --glass-bg: rgba(10, 20, 40, 0.6);
            --border-color: rgba(0, 195, 255, 0.3);
            --primary-glow: rgba(0, 195, 255, 0.7);
            --text-color: #e0e1f0;
            --primary-accent: #00c3ff;
            --user-accent: #00ffaa; /* Used for Player Side / Single Player */
            --system-accent: #ffff00; /* Used for System info */
            --error-accent: #ff4136;
            --opponent-color: #ff99ff; /* New color for Opponent Side */
            --font-heading: 'Orbitron', sans-serif;
            --font-body: 'Roboto Mono', monospace;
        }

        /* Global Reset and Box Model */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Body Styling for Centering and Background */
        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-body);
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Hide scrollbars for full-screen effect */
            background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,0.05) 1px, transparent 0);
            background-size: 20px 20px;
        }

        /* Screen Management */
        .screen {
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .screen.active {
            display: flex; /* Show active screen */
        }
        .hidden {
            display: none !important;
        }

        /* Hub Screen Styling */
        .hub-container {
            text-align: center;
            animation: fadeIn 1s ease-in-out;
            padding: 20px; /* Add padding for mobile */
        }
        .hub-header {
            margin-bottom: 40px;
        }
        .hub-header h1 {
            font-family: var(--font-heading);
            color: var(--primary-accent);
            letter-spacing: 4px;
            text-shadow: 0 0 10px var(--primary-glow);
        }
        .hub-header h2 {
            font-size: 0.9em;
            font-weight: 400;
            color: var(--text-color);
            opacity: 0.7;
        }
        .mode-selection button {
            display: block;
            margin: 20px auto;
            width: 350px;
            padding: 20px;
            font-size: 1.2em;
        }

        /* Creation Screen (Genesis Protocol) Styling */
        .creation-container {
            width: 100%;
            max-width: 900px; /* Still good for larger screens */
            background: var(--glass-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px; /* Reduced padding for mobile */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            animation: fadeIn 1s ease-in-out;
            max-height: 100vh; /* Ensure it doesn't overflow viewport */
            overflow-y: auto; /* Allow scrolling if content is too long */
        }
        .creation-header {
            text-align: center;
            margin-bottom: 20px; /* Reduced margin */
        }
        .creation-header h1 {
            font-family: var(--font-heading);
            color: var(--primary-accent);
            letter-spacing: 4px;
            text-shadow: 0 0 10px var(--primary-glow);
            font-size: 1.8em; /* Adjusted for mobile */
        }
        .creation-header h2 {
            font-size: 0.9em;
            font-weight: 400;
            color: var(--text-color);
            opacity: 0.7;
        }
        .creation-header h3#mode-title { /* Added styling for new mode-title */
            font-size: 1.2em;
            font-family: var(--font-body);
            color: var(--system-accent);
            margin-top: 10px;
        }
        .form-group {
            margin-bottom: 15px; /* Reduced margin */
        }
        .form-group label {
            display: block;
            margin-bottom: 8px; /* Reduced margin */
            color: var(--primary-accent);
            font-weight: 700;
            font-size: 0.95em; /* Adjusted for mobile */
        }
        textarea, select, input[type="text"] {
            width: 100%;
            padding: 10px; /* Reduced padding */
            background: rgba(0,0,0,0.3);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-family: inherit;
            font-size: 0.95em; /* Adjusted for mobile */
            transition: all 0.2s ease;
            resize: vertical;
        }
        textarea:focus, select:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-accent);
            box-shadow: 0 0 10px var(--primary-glow);
        }
        select option {
            background: var(--bg-color); /* Ensure options are readable */
            color: var(--text-color);
        }
        .creation-footer {
            text-align: center;
            margin-top: 20px; /* Reduced margin */
        }
        /* New: Dual input on creation screen */
        .creation-dual-input {
            display: flex;
            gap: 15px; /* Reduced gap */
            margin-bottom: 15px; /* Reduced margin */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .creation-dual-input > div {
            flex: 1;
            min-width: unset; /* Remove min-width to allow more flexible wrapping */
            width: 100%; /* Force full width on small screens by default */
        }
        /* Adjusted min-width for larger mobile devices or tablets in portrait */
        @media (min-width: 480px) {
            .creation-dual-input > div {
                min-width: 250px; /* Allow side-by-side on wider mobiles */
            }
        }


        /* Button Styling */
        button {
            padding: 10px 25px; /* Adjusted padding */
            background-color: transparent;
            color: var(--primary-accent);
            font-family: var(--font-heading);
            cursor: pointer;
            border: 2px solid var(--primary-accent);
            font-size: 1em; /* Adjusted font size */
            border-radius: 4px;
            transition: all 0.2s ease;
            text-shadow: 0 0 5px var(--primary-glow);
        }
        button:hover:not(:disabled) {
            background-color: var(--primary-accent);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--primary-glow);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Game Screen Styling - ADJUSTED FOR TEXT/AUDIO ONLY */
        #genesis-screen {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* Push content to bottom */
            padding-bottom: 130px; /* Adjusted space for input overlay */
        }
        
        /* New Loading Overlay */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7); /* Dark overlay */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
            z-index: 100; /* Higher z-index to cover everything else */
            transition: opacity 0.3s ease-in-out;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #loading-overlay .loader {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--primary-accent);
            border-radius: 50%;
            width: 40px; /* Smaller loader */
            height: 40px; /* Smaller loader */
            animation: spin 1s linear infinite;
            margin: 0 auto 10px; /* Adjusted margin */
        }
        #loading-overlay .loading-text {
            font-family: var(--font-heading);
            color: var(--system-accent);
            text-shadow: 0 0 8px var(--system-accent);
            font-size: 0.9em; /* Adjusted for mobile */
        }
        
        /* Chat Log Overlay - NOW THE MAIN DISPLAY AREA */
        .log-overlay {
            position: static;
            height: 100%;
            width: 100%;
            padding: 20px; /* Reduced padding for mobile */
            overflow-y: scroll;
            background: transparent;
            -webkit-mask-image: none;
            mask-image: none;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            font-size: 0.9em; /* Adjusted font size for mobile readability */
        }
        .log-overlay::-webkit-scrollbar {
            display: block;
            width: 6px; /* Smaller scrollbar */
        }
        .log-overlay::-webkit-scrollbar-track {
            background: rgba(0, 195, 255, 0.1);
            border-radius: 3px;
        }
        .log-overlay::-webkit-scrollbar-thumb {
            background: rgba(0, 195, 255, 0.5);
            border-radius: 3px;
        }
        .log-entry {
            margin-bottom: 10px; /* Reduced margin */
            line-height: 1.5; /* Adjusted line height */
            text-shadow: 1px 1px 3px #000;
            background: rgba(0,0,0,0.4);
            padding: 8px; /* Reduced padding */
            border-radius: 5px;
        }
        .log-entry strong {
            font-weight: 700;
            padding-right: 8px; /* Reduced padding */
            color: var(--primary-accent);
            display: inline;
        }
        /* New: Team specific colors */
        .log-entry strong.player-side {
            color: var(--user-accent);
        }
        .log-entry strong.opponent-side {
            color: var(--opponent-color);
        }
        .log-entry strong.user {
            color: var(--user-accent);
        }
        .log-entry strong span {
            color: var(--text-color);
        }
        .log-entry strong.system-error {
            color: var(--error-accent);
        }
        .log-entry strong.system-info {
            color: var(--system-accent);
        }
        .log-entry span {
            white-space: pre-wrap;
        }
        
        /* Input Overlay (Competitive Chat) - ADJUSTED FOR FULL SCREEN */
        #competitive-input-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: auto;
            background: transparent;
            backdrop-filter: none;
            flex-direction: column;
            justify-content: flex-end;
            padding: 10px; /* Reduced padding */
            align-items: center; /* Center modal in overlay */
        }

        .input-modal-competitive {
            display: flex;
            gap: 10px; /* Reduced gap */
            width: 100%;
            max-width: 900px;
            padding: 15px; /* Reduced padding */
            background: var(--glass-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            flex-direction: column; /* Force vertical stacking on mobile */
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        .input-modal-competitive > div {
            flex: none; /* Prevent flex-grow for stacked items */
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Reduced gap */
        }
        .input-modal-competitive h3 {
            font-family: var(--font-heading);
            margin-bottom: 5px;
            font-size: 1.1em; /* Adjusted font size */
        }
        .chat-form {
            display: flex;
            flex-direction: column;
            gap: 8px; /* Reduced gap */
        }
        .chat-form textarea {
            height: 80px; /* Reduced height for textarea on mobile */
            font-size: 1em; /* Adjusted font size */
            resize: none;
        }
        .input-hint-competitive {
            text-align: center;
            color: rgba(255,255,255,0.6);
            margin-top: 10px; /* Reduced margin */
            font-size: 0.8em; /* Adjusted font size */
        }

        /* STT/Save Button Integration */
        .chat-form-buttons {
            display: flex;
            gap: 8px; /* Reduced gap */
            width: 100%;
            justify-content: stretch;
        }
        .chat-form-buttons button {
            padding: 10px 12px; /* Adjusted padding */
            font-size: 1em; /* Adjusted font size */
            flex-grow: 1; /* Allow send button to grow */
        }
        .chat-form-buttons button.icon-button {
            width: 50px; /* Smaller icon buttons */
            height: 50px; /* Ensure square */
            flex-grow: 0;
            padding: 0;
            font-size: 1.5em; /* Adjusted icon size */
            line-height: 1;
        }
        #mic-btn-rpg.is-listening {
            background: var(--error-accent);
            color: var(--bg-color);
            animation: pulse-red 1s infinite;
        }

        /* Competitive Game Status */
        #game-stats {
            color: var(--system-accent);
            font-size: 0.85em; /* Adjusted font size */
            margin-top: 5px;
            text-align: center;
            opacity: 0.8;
        }

        /* Game Over button styling */
        .game-over-buttons {
            display: flex;
            justify-content: center;
            gap: 15px; /* Reduced gap */
            margin-top: 15px; /* Reduced margin */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }
        .game-over-buttons button {
            flex-grow: 1; /* Allow buttons to grow */
            min-width: 180px; /* Ensure they don't get too small */
        }

        /* NEW: Sandbox Combat Actions Container */
        .sandbox-combat-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            margin-top: 10px;
        }
        .sandbox-combat-actions label {
            color: var(--system-accent);
            font-size: 0.9em;
        }
        .sandbox-combat-actions input {
            background: rgba(0,0,0,0.2);
        }
        .sandbox-combat-actions button {
            background-color: var(--system-accent);
            color: var(--bg-color);
            border: 2px solid var(--system-accent);
            text-shadow: none;
            box-shadow: 0 0 5px var(--system-accent);
        }
        .sandbox-combat-actions button:hover:not(:disabled) {
            background-color: transparent;
            color: var(--system-accent);
            box-shadow: 0 0 10px var(--system-accent);
        }


        /* Keyframe Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes pulse-red {
            0%{box-shadow:0 0 0 0 rgba(255,65,54,.7)}
            70%{box-shadow:0 0 0 10px rgba(255,65,54,0)}
            100%{box-shadow:0 0 0 0 rgba(255,65,54,0)}
        }

        /* Media Queries for better responsiveness on larger screens (tablet/desktop) */
        @media (min-width: 768px) {
            .creation-container {
                padding: 40px;
            }
            .creation-header h1 {
                font-size: 2.5em;
            }
            .form-group label {
                font-size: 1em;
            }
            textarea, select, input[type="text"] {
                padding: 12px;
                font-size: 1em;
            }
            button {
                padding: 12px 30px;
                font-size: 1.1em;
            }

            #genesis-screen {
                padding-bottom: 150px;
            }
            .log-overlay {
                padding: 40px;
                font-size: 1em;
            }
            .log-overlay::-webkit-scrollbar {
                width: 8px;
            }
            .log-entry {
                margin-bottom: 15px;
                padding: 10px;
            }
            .log-entry strong {
                padding-right: 10px;
            }
            #loading-overlay .loader {
                width: 50px;
                height: 50px;
            }
            #loading-overlay .loading-text {
                font-size: 1em;
            }

            #competitive-input-overlay {
                padding: 20px;
            }
            .input-modal-competitive {
                padding: 20px;
                flex-direction: row; /* Revert to row for larger screens */
            }
            .input-modal-competitive > div {
                flex: 1; /* Allow flex-grow again */
                width: auto; /* Allow width to be determined by flex */
                gap: 10px;
            }
            .input-modal-competitive h3 {
                font-size: 1.2em;
            }
            .chat-form {
                gap: 10px;
            }
            .chat-form textarea {
                height: 100px;
                font-size: 1.1em;
            }
            .input-hint-competitive {
                margin-top: 15px;
                font-size: 0.9em;
            }
            .chat-form-buttons {
                gap: 10px;
            }
            .chat-form-buttons button {
                padding: 12px 15px;
                font-size: 1.1em;
            }
            .chat-form-buttons button.icon-button {
                width: 60px;
                font-size: 1.8em;
            }
            #game-stats {
                font-size: 0.9em;
            }
            .game-over-buttons {
                gap: 20px;
                margin-top: 20px;
                flex-wrap: nowrap;
            }
            .game-over-buttons button {
                flex-grow: 0;
            }
        }
    </style>
</head>
<body>
    <div id="hub-screen" class="screen active">
        <div class="hub-container">
            <header class="hub-header">
                <h1>GlassICE</h1>
                <h2>v27.0 // Maestro</h2>
            </header>
            <div class="mode-selection">
                <button id="launch-sandbox-btn">Launch Sandbox Chronicle</button> <!-- Renamed from single player -->
                <button id="launch-competitive-btn">Launch Competitive Chronicle</button>
            </div>
        </div>
    </div>

    <!-- Genesis (RPG) Screen Structure -->
    <div id="genesis-screen" class="screen">
        <!-- The main chat log will fill this screen directly -->
        <div class="log-overlay" id="chat-log-rpg"></div>

        <!-- New Loading Overlay -->
        <div id="loading-overlay" class="hidden">
            <div class="loader"></div>
            <p class="loading-text" id="loader-text-rpg">Loading...</p>
        </div>
    </div>

    <!-- Creation Screen (moved here to be toggleable) -->
    <div id="creation-screen-rpg" class="screen hidden">
        <div class="creation-container">
            <header class="creation-header">
                <h2>Genesis Protocol</h2>
                <h3 id="mode-title">Dynamic Narrative Setup</h3> <!-- New: To display selected mode -->
            </header>
            <main class="creation-form">
                <section class="form-group">
                    <label for="prompt-rpg">Describe the Game's Setting & Initial Conflict:</label>
                    <textarea id="prompt-rpg" placeholder="A desolate, wind-swept plain where ancient ruins jut from the earth, and an unseen power stirs beneath..."></textarea>
                </section>
                <div class="creation-dual-input">
                    <section class="form-group">
                        <label for="player-side-name-input">Your Side's Name:</label>
                        <input type="text" id="player-side-name-input" placeholder="E.g., The Rebel Alliance, Godzilla, The Knights of Sol"></input>
                    </section>
                    <section class="form-group" id="opponent-side-name-form-group">
                        <label for="opponent-side-name-input">Opponent's Side Name (Competitive Only):</label>
                        <input type="text" id="opponent-side-name-input" placeholder="E.g., The Galactic Empire, Dallas Cowboys, The Shadow Cult"></input>
                    </section>
                </div>
                <section class="form-group">
                    <label for="initial-player-side-prompt" style="color: var(--user-accent);" id="initial-player-side-label">Your Side's Opening Strategy & Composition:</label>
                    <textarea id="initial-player-side-prompt" placeholder="Your side's characters (e.g., Luke, Han, Leia) and their initial actions/strategy."></textarea>
                </section>
                <section class="form-group" id="initial-opponent-side-prompt-form-group">
                    <label for="initial-opponent-side-prompt" style="color: var(--opponent-color);" id="initial-opponent-side-label">Opponent's Side Opening Strategy & Composition (Competitive Only):</label>
                    <textarea id="initial-opponent-side-prompt" placeholder="Opponent's characters (e.g., Vader, Stormtroopers) and their initial actions/strategy."></textarea>
                </section>
                
                <!-- NEW: GM Selection for Sandbox Mode (hidden for competitive) -->
                <section class="form-group" id="gm-selection-group">
                    <label for="gm-selector">Select Director:</label>
                    <select id="gm-selector"></select>
                </section>
                <section class="form-group">
                    <label>Selected Director:</label>
                    <p id="selected-gm-display" style="color: var(--primary-accent); font-family: var(--font-heading); font-size: 1.1em;"></p>
                </section>
            </main>
            <footer class="creation-footer">
                <button id="start-btn-rpg">Prepare Chronicle</button>
            </footer>
        </div>
    </div>


    <!-- Competitive Narrative Input Overlay -->
    <div id="competitive-input-overlay" class="hidden">
        <h2 id="turn-status">Turn Start: Player's Actions</h2>
        <p id="game-stats" class="hidden"></p> <!-- New element for game stats -->
        <div class="input-modal-competitive">
            <div class="player-side-input">
                <h3 id="player-side-label" style="color: var(--user-accent);">Player Side: Player</h3>
                <form id="chat-form-player-side" class="chat-form">
                    <textarea id="user-input-player-side" placeholder="Describe your actions or your side's strategy..." autocomplete="off"></textarea>
                    <div class="chat-form-buttons">
                        <button type="button" id="save-btn-rpg" class="icon-button" title="Save Chronicle">💾</button>
                        <button type="button" id="mic-btn-rpg" class="icon-button" title="Hold to Record Voice">🎤</button>
                        <button type="submit" id="submit-turn-btn">Submit Turn Actions</button>
                    </div>
                </form>
            </div>
            <div class="opponent-side-input hidden" id="opponent-input-container"> <!-- Added ID -->
                <h3 id="opponent-side-label" style="color: var(--opponent-color);">Opponent Side: Opponent</h3>
                <form id="chat-form-opponent-side" class="chat-form">
                    <textarea id="user-input-opponent-side" placeholder="Describe Opponent's actions (for competitive play only)..." autocomplete="off"></textarea>
                    <div class="chat-form-buttons">
                        <!-- Submit button removed from here, combined into one overall submit -->
                    </div>
                </form>
            </div>
            <!-- NEW: Sandbox Combat Actions Container -->
            <div class="sandbox-combat-actions hidden" id="sandbox-combat-actions-container">
                <h3>Initiate Combat</h3>
                <label for="sandbox-opponent-description">Who/What do you want to fight?</label>
                <input type="text" id="sandbox-opponent-description" placeholder="E.g., A pack of dire wolves, The rogue AI, A rival adventurer">
                <button id="initiate-combat-btn">Initiate Combat</button>
            </div>
        </div>
        <p class="input-hint-competitive" id="input-hint-text">Hold SPACE to Speak (Player Side) | Tap SPACE to Type (Player Side) | Click anywhere to Type (Player Side)</p>
        <div class="game-over-buttons hidden"> <!-- NEW: Container for game over buttons -->
            <button id="new-game-btn">Start New Chronicle</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
           const API_URL = "https://glassice.onrender.com"

            const hubScreen = document.getElementById('hub-screen');
            const genesisScreen = document.getElementById('genesis-screen'); // This is the main game screen container
            const creationScreen = document.getElementById('creation-screen-rpg'); // Moved to top level for toggling

            const launchSandboxBtn = document.getElementById('launch-sandbox-btn'); // Renamed
            const launchCompetitiveBtn = document.getElementById('launch-competitive-btn');

            // Store game state for dynamic narrative mode
            let dynamicGameState = {
                currentSceneId: null,
                playerSideName: 'Player',
                opponentSideName: 'Opponent',
                currentAudio: null,
                personas: [], // Cached personas from API
                turnPhase: 'player_side_input', // 'player_side_input', 'adjudicating'
                playerSideInputBuffer: '',
                opponentSideInputBuffer: '',
                gameMode: 'sandbox', // NEW: 'sandbox', 'competitive', 'sandbox_combat'
                isListening: false, // STT: State for microphone recording
                gmPersonaId: null, // Stored once determined by mode or selection
                currentRound: 0, // Current round number for competitive/combat
                playerHP: 0,     // Player's current HP
                opponentHP: 0,   // Opponent's current HP
                gameOver: false,  // Game over flag
                sandboxOpponentName: null // NEW: Stores the name of the opponent in sandbox_combat
            };

            let mediaRecorder; // STT: MediaRecorder instance for audio input
            let audioChunks = []; // STT: Array to store audio data chunks
            let spacebarTimer = null; // STT: Timer for distinguishing tap vs. hold on spacebar
            let isHoldingSpace = false; // STT: Flag for spacebar hold state

            // Global UI elements for dynamic narrative mode
            const competitiveInputOverlay = document.getElementById('competitive-input-overlay');
            const turnStatus = document.getElementById('turn-status');
            const userInputPlayerSide = document.getElementById('user-input-player-side');
            const userInputOpponentSide = document.getElementById('user-input-opponent-side');
            const submitTurnBtn = document.getElementById('submit-turn-btn'); // Combined submit button
            const chatFormPlayerSide = document.getElementById('chat-form-player-side');
            const chatFormOpponentSide = document.getElementById('chat-form-opponent-side'); // Still exists for opponent's textarea
            const playerSideLabel = document.getElementById('player-side-label');
            const opponentSideLabel = document.getElementById('opponent-side-label');
            const opponentInputContainer = document.getElementById('opponent-input-container'); // Select the div container

            const micBtnRpg = document.getElementById('mic-btn-rpg');
            const saveBtnRpg = document.getElementById('save-btn-rpg');
            const gameStatsDisplay = document.getElementById('game-stats'); // Game stats display
            const gameOverButtonsContainer = document.querySelector('.game-over-buttons'); // Game over buttons container
            const newGameBtn = document.getElementById('new-game-btn'); // New game button

            // NEW Sandbox combat elements
            const sandboxCombatActionsContainer = document.getElementById('sandbox-combat-actions-container');
            const sandboxOpponentDescriptionInput = document.getElementById('sandbox-opponent-description');
            const initiateCombatBtn = document.getElementById('initiate-combat-btn');
            const inputHintText = document.getElementById('input-hint-text'); // Hint text for input

            // Elements from Creation Screen (for setup)
            let ui = {};
            ui.chatLog = document.getElementById('chat-log-rpg'); // chatLog is directly in genesisScreen
            // Loader related elements
            const loaderOverlay = document.getElementById('loading-overlay');
            const loaderText = document.getElementById('loader-text-rpg');


            // Helper to update the state of the input forms and labels based on gameMode
            function updateInputState() {
                const isCombatMode = dynamicGameState.gameMode === 'competitive' || dynamicGameState.gameMode === 'sandbox_combat';
                const isSandboxOpenEnded = dynamicGameState.gameMode === 'sandbox';

                // Labels
                playerSideLabel.textContent = `${dynamicGameState.playerSideName}:`;
                opponentSideLabel.textContent = `${dynamicGameState.sandboxOpponentName || dynamicGameState.opponentSideName}:`;

                // Input Fields and Buttons visibility
                // Opponent input field: only shown in 'competitive' mode
                opponentInputContainer.classList.toggle('hidden', dynamicGameState.gameMode !== 'competitive');
                // Sandbox combat initiation area: only shown in 'sandbox' (open-ended) mode
                sandboxCombatActionsContainer.classList.toggle('hidden', !isSandboxOpenEnded);

                // Mic and Save buttons: always shown for sandbox and sandbox_combat. Hidden for competitive.
                micBtnRpg.classList.toggle('hidden', dynamicGameState.gameMode === 'competitive');
                saveBtnRpg.classList.toggle('hidden', false); // Always show save button

                // Game Stats display: only shown in combat modes
                gameStatsDisplay.classList.toggle('hidden', !isCombatMode);
                if (isCombatMode) {
                    gameStatsDisplay.textContent = `Round: ${dynamicGameState.currentRound} | ${dynamicGameState.playerSideName} HP: ${dynamicGameState.playerHP} | ${dynamicGameState.sandboxOpponentName || dynamicGameState.opponentSideName} HP: ${dynamicGameState.opponentHP}`;
                }

                // Input hint text
                if (isSandboxOpenEnded) {
                    inputHintText.textContent = "Hold SPACE to Speak (Your Side) | Tap SPACE to Type (Your Side) | Click anywhere to Type (Your Side)";
                } else if (isCombatMode) {
                    inputHintText.textContent = "Enter actions for your side" + (dynamicGameState.gameMode === 'competitive' ? " and the opponent." : ".");
                }

                // Handle Game Over state
                if (dynamicGameState.gameOver) {
                    turnStatus.textContent = "Chronicle Concluded!";
                    userInputPlayerSide.disabled = true;
                    userInputOpponentSide.disabled = true;
                    submitTurnBtn.disabled = true;
                    micBtnRpg.disabled = true;
                    saveBtnRpg.disabled = false; // Allow saving chronicle at the end
                    gameStatsDisplay.textContent = `FINAL ROUND: ${dynamicGameState.currentRound} | ${dynamicGameState.playerSideName} HP: ${dynamicGameState.playerHP} | ${dynamicGameState.sandboxOpponentName || dynamicGameState.opponentSideName} HP: ${dynamicGameState.opponentHP} | GAME OVER`;
                    gameOverButtonsContainer.classList.remove('hidden'); // Show new game button
                    return; // Exit early if game is over
                }

                // Normal game state (not game over)
                gameOverButtonsContainer.classList.add('hidden'); // Hide new game button
                switch (dynamicGameState.turnPhase) {
                    case 'player_side_input':
                        if (isSandboxOpenEnded) {
                            turnStatus.textContent = `Your Turn: Describe Actions (Sandbox Mode)`;
                            userInputPlayerSide.placeholder = `Describe your actions as ${dynamicGameState.playerSideName}...`;
                            userInputOpponentSide.placeholder = `(Opponent input not needed in Sandbox)`;
                        } else if (dynamicGameState.gameMode === 'sandbox_combat') {
                            turnStatus.textContent = `Combat Round ${dynamicGameState.currentRound}: Describe Your Attack/Defense!`;
                            userInputPlayerSide.placeholder = `Describe your combat actions...`;
                            userInputOpponentSide.placeholder = `(AI will act for ${dynamicGameState.sandboxOpponentName})`; // Opponent input disabled
                        } else { // competitive
                            turnStatus.textContent = `It's Your Turn, ${dynamicGameState.playerSideName} & ${dynamicGameState.opponentSideName}!`;
                            userInputPlayerSide.placeholder = `Describe ${dynamicGameState.playerSideName}'s actions...`;
                            userInputOpponentSide.placeholder = `Describe ${dynamicGameState.opponentSideName}'s actions...`;
                        }
                        userInputPlayerSide.disabled = false;
                        userInputOpponentSide.disabled = dynamicGameState.gameMode !== 'competitive'; // Only competitive allows opponent input
                        submitTurnBtn.disabled = false;
                        micBtnRpg.disabled = false;
                        saveBtnRpg.disabled = false;
                        userInputPlayerSide.focus();
                        break;
                    case 'adjudicating':
                        turnStatus.textContent = "The Director is Adjudicating...";
                        userInputPlayerSide.disabled = false; // Allow typing during narration
                        userInputOpponentSide.disabled = true; // Always disable opponent input while adjudicating
                        submitTurnBtn.disabled = true;
                        micBtnRpg.disabled = true;
                        saveBtnRpg.disabled = true;
                        break;
                }
            }

            // Function to dynamically build the creation UI and main game screen (log)
            function buildCreationAndGameUI() {
                // Populate ui object with creation screen elements once they are active
                ui.prompt = document.getElementById('prompt-rpg');
                ui.playerSideNameInput = document.getElementById('player-side-name-input');
                ui.opponentSideNameInput = document.getElementById('opponent-side-name-input');
                ui.initialPlayerSidePrompt = document.getElementById('initial-player-side-prompt');
                ui.initialOpponentSidePrompt = document.getElementById('initial-opponent-side-prompt');
                ui.startBtn = document.getElementById('start-btn-rpg');
                ui.selectedGmDisplay = document.getElementById('selected-gm-display'); // For displaying selected GM name
                ui.initialPlayerSideLabel = document.getElementById('initial-player-side-label');
                ui.initialOpponentSidePromptFormGroup = document.getElementById('initial-opponent-side-prompt-form-group');
                ui.opponentSideNameFormGroup = document.getElementById('opponent-side-name-form-group');
                ui.gmSelector = document.getElementById('gm-selector'); // NEW GM Selector
                ui.gmSelectionGroup = document.getElementById('gm-selection-group'); // NEW GM Selection Group
                ui.modeTitle = document.getElementById('mode-title'); // NEW Mode Title
            }

            // Attempts to unlock Web Audio API context on user interaction
            function unlockAudioContext() {
                const silentSound = new Audio("data:audio/mp3;base64,SUQzBAAAAAABEVRYWFgAAAAtAAADY229tbWVudABCaWdTb3VuZEJhbmsuY29tIC8gTGFTb25vdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLnNvdGhlcXVlLm9yZwBURU5DAAAAHQAAA1N3aXRjaCBQbHVzIMKrIE5DSCBTb2Z0d2FyZQBUSVQyAAAABgAAAzIyMzUAVFNTRQAAAAgAAANMYXZmNTcuODMuMTAwA//zQsRbAAADSAAAAASteIEACH5w/AARgAAAAIAAQZgAAAAA//zQsRRAAAAAYNaaQAAAAAA//zQsTUAABAIAAAAAAAAFwAAAAAZ4AAAAn8A//zQsVcAAANIAAAAAAABaYgAIMj1w/AARgAAAAIAAQZgAAAAA//zQsV0AAAAABhpjoAADDgAAAAA//zQsWkAAAAAIAAAAAAAAFwAAAAAn4AAAAn8A//zQsYQAAANIAAAAAAABoYgAINj1w/AARgAAAAIAAQZgAAAAA//zQsY0AAAAABprpAAAADAAA");
                silentSound.volume = 0;
                silentSound.play().catch(() => {});
                console.log("[PANE GLASS] Audio context unlocked.");
            }

            // Typewriter effect for displaying text in chat log (NOW RETURNS A PROMISE)
            const typewriter = (el, txt) => {
                return new Promise(resolve => {
                    let i = 0;
                    el.innerHTML = "";
                    const typingInterval = setInterval(() => {
                        if (i < txt.length) {
                            el.innerHTML += txt.charAt(i);
                            i++;
                            ui.chatLog.scrollTop = ui.chatLog.scrollHeight;
                        } else {
                            clearInterval(typingInterval);
                            resolve(); // Resolve the promise when typing is complete
                        }
                    }, 15);
                });
            };

            // Plays audio from a base64 encoded string (NOW RETURNS A_PROMISE)
            const playAudio = (b64) => {
                return new Promise(resolve => {
                    if (dynamicGameState.currentAudio) {
                        dynamicGameState.currentAudio.pause();
                        dynamicGameState.currentAudio = null;
                    }
                    if (b64) {
                        dynamicGameState.currentAudio = new Audio("data:audio/mp3;base64," + b64);
                        dynamicGameState.currentAudio.play().catch(e => {
                            console.error("Audio playback failed:", e);
                            resolve();
                        });
                        dynamicGameState.currentAudio.onended = () => resolve();
                    } else {
                        resolve();
                    }
                });
            };

            // Adds an entry to the chat log with typewriter effect (uses promise-returning typewriter)
            const addLog = (content, author, className) => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'log-entry';

                const authorStrong = document.createElement('strong');
                authorStrong.className = className || 'gm'; 
                authorStrong.textContent = `${author}:`;

                const contentSpan = document.createElement('span');
                contentSpan.style.color = 'var(--text-color)'; // Ensure text color is set
                entryDiv.appendChild(authorStrong);
                entryDiv.appendChild(contentSpan);
                ui.chatLog.appendChild(entryDiv);

                return typewriter(contentSpan, content || '');
            };

            // Toggles the overall loading overlay and its text
            const setLoading = (isLoading, message = "Processing...") => {
                loaderText.textContent = message;
                loaderOverlay.classList.toggle('hidden', !isLoading);
            };

            // This function is just a placeholder after visuals are removed
            const updateCanvas = (htmlContent) => {
                return Promise.resolve();
            };

            // Generic API fetch wrapper with error handling
            async function fetchAPI(endpoint, options = {}) {
                try {
                    const response = await fetch(`${API_URL}${endpoint}`, options);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: `HTTP Error: ${response.status} ${response.statusText}` }));
                        throw new Error(errorData.error);
                    }
                    return response.json();
                } catch (error) {
                    console.error(`API Error on ${endpoint}:`, error);
                    addLog(`Server communication failed: ${error.message}. Please check server console.`, "System", "system-error");
                    setLoading(false); 
                    toggleCompetitiveInputOverlay(true); 
                    dynamicGameState.turnPhase = 'player_side_input'; 
                    updateInputState();
                    throw error;
                }
            }

            // Toggles the competitive input overlay
            const toggleCompetitiveInputOverlay = (show) => {
                competitiveInputOverlay.classList.toggle('hidden', !show);
                if (show) {
                    updateInputState();
                }
            };

            // STT: Handles microphone button press (start recording)
            const handleMicPress = () => {
                if (dynamicGameState.isListening || dynamicGameState.gameOver) return; // Prevent recording if game is over

                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        dynamicGameState.isListening = true;
                        micBtnRpg.classList.add('is-listening');
                        mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                        audioChunks = [];

                        mediaRecorder.addEventListener("dataavailable", e => {
                            audioChunks.push(e.data);
                        });

                        mediaRecorder.addEventListener("stop", () => {
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            const formData = new FormData();
                            formData.append('audio', audioBlob, 'user_audio.webm');
                            
                            processTurnInput({ formData: formData });
                            stream.getTracks().forEach(track => track.stop());
                        });

                        mediaRecorder.start();
                    })
                    .catch(err => {
                        alert("Microphone access was denied. Please allow microphone access to use voice input.");
                        console.error("Microphone access error:", err);
                    });
            };

            // STT: Handles microphone button release (stop recording)
            const handleMicRelease = () => {
                if (!dynamicGameState.isListening || !mediaRecorder || mediaRecorder.state !== "recording") {
                    return;
                }
                mediaRecorder.stop();
                micBtnRpg.classList.remove('is-listening');
                dynamicGameState.isListening = false;
            };

            // Processes input (text or voice) for the active player/team
            const processTurnInput = async ({ message, formData }) => {
                if (dynamicGameState.gameOver) return; // Do not process if game is over

                const isVoiceInput = !!formData;
                toggleCompetitiveInputOverlay(false); // Hide input overlay immediately

                dynamicGameState.turnPhase = 'adjudicating';
                updateInputState();

                // Log player side message (or voice placeholder) immediately before API call
                if (message) { 
                    dynamicGameState.playerSideInputBuffer = message; 
                    await addLog(message, dynamicGameState.playerSideName, 'player-side');
                    userInputPlayerSide.value = '';
                } else { // Voice input
                    dynamicGameState.playerSideInputBuffer = "... (Speaking)";
                    await addLog("... (Speaking)", dynamicGameState.playerSideName, 'system-info');
                }
                
                // If competitive, log opponent's input from the field immediately
                // Only for 'competitive' mode, as 'sandbox_combat' opponent action is generated by GM
                if (dynamicGameState.gameMode === 'competitive') {
                    dynamicGameState.opponentSideInputBuffer = userInputOpponentSide.value.trim();
                    if (dynamicGameState.opponentSideInputBuffer) { // Only log if there's actual input
                        await addLog(dynamicGameState.opponentSideInputBuffer, dynamicGameState.opponentSideName, 'opponent-side');
                    }
                    userInputOpponentSide.value = '';
                } else {
                    dynamicGameState.opponentSideInputBuffer = ''; // Ensure it's empty for non-competitive modes
                }

                setLoading(true, isVoiceInput ? "Transcribing Voice Input..." : "Processing Actions...");

                try {
                    const endpoint = isVoiceInput ? `/api/dynamic-narrative/${dynamicGameState.currentSceneId}/turn/voice` : `/api/dynamic-narrative/${dynamicGameState.currentSceneId}/turn`;
                    const payload = isVoiceInput ? formData : JSON.stringify({ 
                        playerSideMessage: dynamicGameState.playerSideInputBuffer, 
                        opponentSideMessage: dynamicGameState.opponentSideInputBuffer,
                        gameMode: dynamicGameState.gameMode // Pass current game mode
                    });
                    const options = isVoiceInput ? { method: 'POST', body: payload } : { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: payload };

                    const data = await fetchAPI(endpoint, options);

                    // Update game state from server response (NEW)
                    dynamicGameState.currentRound = data.currentRound || dynamicGameState.currentRound;
                    dynamicGameState.playerHP = data.playerHP; // Update player HP
                    dynamicGameState.opponentHP = data.opponentHP; // Update opponent HP
                    dynamicGameState.gameOver = data.gameOver || false;
                    dynamicGameState.gameMode = data.gameMode; // IMPORTANT: gameMode might change (e.g., sandbox_combat -> sandbox)
                    dynamicGameState.sandboxOpponentName = data.sandboxOpponentName || null; // Clear if combat ended

                    // 1. Log transcribed message if it was voice input (this is *before* audio/text playback)
                    if (isVoiceInput && data.transcribedMessage) {
                        // Check if the "... (Speaking)" placeholder is the last entry and remove it
                        if (ui.chatLog.lastChild && ui.chatLog.lastChild.querySelector('strong.system-info') && ui.chatLog.lastChild.querySelector('strong.system-info').textContent.includes('Speaking')) {
                            ui.chatLog.lastChild.remove();
                        }
                        await addLog(data.transcribedMessage, dynamicGameState.playerSideName, 'player-side');
                    }
                    
                    // 2. Hide loader
                    setLoading(false); 

                    // 3. Populate text and play audio simultaneously with offset
                    const textDisplayPromise = addLog(data.response.narration, dynamicGameState.personas.find(p => p.actor_id === data.character)?.name || 'Director');
                    const audioPlayPromise = new Promise(resolve => {
                        setTimeout(async () => {
                            await playAudio(data.response.audio_base_64);
                            resolve(); // Resolve this promise when audio finishes
                        }, 1500); // 1.5 second delay before speech starts
                    });
                    await Promise.all([textDisplayPromise, audioPlayPromise]);


                    // Prepare for next turn OR handle game over
                    userInputPlayerSide.value = '';
                    userInputOpponentSide.value = '';
                    dynamicGameState.playerSideInputBuffer = '';
                    dynamicGameState.opponentSideInputBuffer = '';
                    
                    if (dynamicGameState.gameOver) {
                        await addLog(`Game Over! ${data.finalReason || "The conflict reached a decisive end."}`, "System", "system-error");
                        // Inputs will be permanently disabled by updateInputState()
                    } else {
                        // For sandbox, the GM's narration *is* the prompt. For combat modes, we give a status update.
                        if (dynamicGameState.gameMode === 'competitive' || dynamicGameState.gameMode === 'sandbox_combat') {
                            let turnPrompt;
                            const currentOpponentName = dynamicGameState.sandboxOpponentName || dynamicGameState.opponentSideName;
                            if (data.turnOutcomeWinner === 'opponent_side') {
                                turnPrompt = `${dynamicGameState.playerSideName} was outmaneuvered in Round ${dynamicGameState.currentRound}. You are at ${dynamicGameState.playerHP} HP! Describe your next actions.`;
                            } else if (data.turnOutcomeWinner === 'player_side') {
                                turnPrompt = `Victory in Round ${dynamicGameState.currentRound}! ${currentOpponentName} is at ${dynamicGameState.opponentHP} HP. Describe your next actions.`;
                            } else { // Draw or undefined
                                turnPrompt = `Round ${dynamicGameState.currentRound} was a draw. Both sides are at ${dynamicGameState.playerHP} HP. Describe your next actions.`;
                            }
                            await addLog(turnPrompt, "System", "system-info");
                        }
                        dynamicGameState.turnPhase = 'player_side_input';
                    }
                    toggleCompetitiveInputOverlay(true); // Show inputs after everything is loaded, with correct state
                    updateInputState(); // Ensure UI reflects final state (disabled if game over)

                } catch (e) {
                    console.error("Failed to process turn:", e);
                    setLoading(false);
                    toggleCompetitiveInputOverlay(true);
                    dynamicGameState.turnPhase = 'player_side_input';
                    updateInputState();
                }
            };


            // Function to prepare chronicle for SANDBOX mode
            const prepareSandboxChronicle = async () => {
                const gameSettingPrompt = ui.prompt.value.trim();
                const playerSideName = ui.playerSideNameInput.value.trim();
                const initialPlayerSidePrompt = ui.initialPlayerSidePrompt.value.trim();
                const selectedGmId = ui.gmSelector.value; // Get selected GM for sandbox

                if (!gameSettingPrompt || !playerSideName || !initialPlayerSidePrompt) {
                    alert("Please provide the game setting, your side's name, and your side's opening strategy.");
                    return;
                }

                dynamicGameState.gameMode = 'sandbox'; // Set new game mode
                dynamicGameState.playerSideName = playerSideName;
                dynamicGameState.opponentSideName = ""; // Explicitly empty for sandbox
                dynamicGameState.gmPersonaId = selectedGmId; // Set GM for this game
                dynamicGameState.currentRound = 0; // Reset
                dynamicGameState.playerHP = 0; // Not applicable for open-ended sandbox
                dynamicGameState.opponentHP = 0; // Not applicable for open-ended sandbox
                dynamicGameState.gameOver = false; // Reset
                dynamicGameState.sandboxOpponentName = null; // Clear any previous opponent

                setLoading(true, "Preparing Sandbox Chronicle...");

                try {
                    const data = await fetchAPI('/api/dynamic-narrative/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            gameSettingPrompt: gameSettingPrompt,
                            playerSideName: dynamicGameState.playerSideName,
                            opponentSideName: dynamicGameState.opponentSideName, // Will be empty
                            initialPlayerSidePrompt: initialPlayerSidePrompt,
                            initialOpponentSidePrompt: "", // Ensure empty for sandbox
                            selectedGmPersonaId: dynamicGameState.gmPersonaId,
                            gameMode: dynamicGameState.gameMode,
                        })
                    });

                    dynamicGameState.currentSceneId = data.sceneId;
                    dynamicGameState.gameMode = data.gameMode; // Update with server's confirmed mode
                    
                    creationScreen.classList.remove('active'); // Hide creation screen
                    genesisScreen.classList.add('active'); // Show main game screen (log overlay)

                    setLoading(false); // Hide loader before narration
                    // Populate text and play audio simultaneously with offset
                    const textDisplayPromise = addLog(data.response.narration, dynamicGameState.personas.find(p => p.actor_id === data.character)?.name || 'Director');
                    const audioPlayPromise = new Promise(resolve => {
                        setTimeout(async () => {
                            await playAudio(data.response.audio_base_64);
                            resolve(); // Resolve this promise when audio finishes
                        }, 1500); // 1.5 second delay before speech starts
                    });
                    await Promise.all([textDisplayPromise, audioPlayPromise]);
                                        
                    toggleCompetitiveInputOverlay(true); // Show inputs
                    dynamicGameState.turnPhase = 'player_side_input';
                    updateInputState();

                } catch (e) {
                    console.error("Failed to prepare sandbox chronicle:", e);
                    setLoading(false);
                }
            };

            // Function to prepare chronicle for COMPETITIVE mode
            const prepareCompetitiveChronicle = async () => {
                const gameSettingPrompt = ui.prompt.value.trim();
                const playerSideName = ui.playerSideNameInput.value.trim();
                const opponentSideName = ui.opponentSideNameInput.value.trim();
                const initialPlayerSidePrompt = ui.initialPlayerSidePrompt.value.trim();
                const initialOpponentSidePrompt = ui.initialOpponentSidePrompt.value.trim();
                const gmId = "Tactician_GM"; // Fixed GM for competitive

                if (!gameSettingPrompt || !playerSideName || !opponentSideName || !initialPlayerSidePrompt || !initialOpponentSidePrompt) {
                    alert("Please provide the game setting, both sides' names, and both sides' opening strategies.");
                    return;
                }

                dynamicGameState.gameMode = 'competitive'; // Set new game mode
                dynamicGameState.playerSideName = playerSideName;
                dynamicGameState.opponentSideName = opponentSideName;
                dynamicGameState.gmPersonaId = gmId; // Set GM for this game
                dynamicGameState.currentRound = 0; // Reset
                dynamicGameState.playerHP = 3; // Starting HP for competitive
                dynamicGameState.opponentHP = 3; // Starting HP for competitive
                dynamicGameState.gameOver = false; // Reset
                dynamicGameState.sandboxOpponentName = null; // Clear any previous opponent

                setLoading(true, "Preparing Competitive Chronicle...");

                try {
                    const data = await fetchAPI('/api/dynamic-narrative/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            gameSettingPrompt: gameSettingPrompt,
                            playerSideName: dynamicGameState.playerSideName,
                            opponentSideName: dynamicGameState.opponentSideName,
                            initialPlayerSidePrompt: initialPlayerSidePrompt,
                            initialOpponentSidePrompt: initialOpponentSidePrompt,
                            selectedGmPersonaId: dynamicGameState.gmPersonaId,
                            gameMode: dynamicGameState.gameMode,
                        })
                    });

                    dynamicGameState.currentSceneId = data.sceneId;
                    dynamicGameState.gameMode = data.gameMode;
                    dynamicGameState.currentRound = data.currentRound || 0;
                    dynamicGameState.playerHP = data.playerHP;
                    dynamicGameState.opponentHP = data.opponentHP;
                    dynamicGameState.gameOver = data.gameOver || false;

                    creationScreen.classList.remove('active');
                    genesisScreen.classList.add('active'); // Show main game screen (log overlay)

                    setLoading(false); // Hide loader before narration
                    // Populate text and play audio simultaneously with offset
                    const textDisplayPromise = addLog(data.response.narration, dynamicGameState.personas.find(p => p.actor_id === data.character)?.name || 'The Grand Tactician');
                    const audioPlayPromise = new Promise(resolve => {
                        setTimeout(async () => {
                            await playAudio(data.response.audio_base_64);
                            resolve(); // Resolve this promise when audio finishes
                        }, 1500); // 1.5 second delay before speech starts
                    });
                    await Promise.all([textDisplayPromise, audioPlayPromise]);
                    
                    await addLog(`It's your turn, ${dynamicGameState.playerSideName} & ${dynamicGameState.opponentSideName}: describe your next actions.`, "System", "system-info");
                    
                    toggleCompetitiveInputOverlay(true); // Show inputs
                    dynamicGameState.turnPhase = 'player_side_input';
                    updateInputState();

                } catch (e) {
                    console.error("Failed to prepare competitive chronicle:", e);
                    setLoading(false);
                }
            };


            // Save adventure
            const saveAdventure = async () => {
                if (!dynamicGameState.currentSceneId) {
                    addLog("No active chronicle to save.", "System", "system-info");
                    return;
                }
                addLog("Saving chronicle...", "System", "system-info");
                try {
                    const data = await fetchAPI(`/api/adventure/${dynamicGameState.currentSceneId}/save`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ origin: window.location.origin })
                    });
                    addLog(`Chronicle saved as ${data.fileName}`, "System", "system-info");
                } catch (e) {
                    console.error("Failed to save chronicle:", e);
                }
            };

            // Function to reset game state and return to hub
            const startNewGame = () => {
                // Reset dynamicGameState to initial values
                dynamicGameState = {
                    currentSceneId: null,
                    playerSideName: 'Player',
                    opponentSideName: 'Opponent',
                    currentAudio: null,
                    personas: dynamicGameState.personas, // Keep cached personas
                    turnPhase: 'player_side_input',
                    playerSideInputBuffer: '',
                    opponentSideInputBuffer: '',
                    gameMode: 'sandbox', // Default for new game start
                    isListening: false,
                    gmPersonaId: null,
                    currentRound: 0,
                    playerHP: 0,
                    opponentHP: 0,
                    gameOver: false,
                    sandboxOpponentName: null
                };

                // Clear chat log
                ui.chatLog.innerHTML = '';

                // Hide game screen and input overlay
                genesisScreen.classList.remove('active');
                competitiveInputOverlay.classList.add('hidden');
                creationScreen.classList.add('hidden'); // Ensure creation screen is also hidden
                creationScreen.classList.remove('active');

                // Show hub screen
                hubScreen.classList.add('active');

                // Clear input fields (just in case they were holding text)
                userInputPlayerSide.value = '';
                userInputOpponentSide.value = '';
                sandboxOpponentDescriptionInput.value = ''; // Clear sandbox opponent input

                // Restore initial display for creation screen form
                ui.opponentSideNameFormGroup.classList.remove('hidden');
                ui.initialOpponentSidePromptFormGroup.classList.remove('hidden');
                ui.initialPlayerSideLabel.textContent = "Your Side's Opening Strategy & Composition:";
                ui.gmSelectionGroup.classList.remove('hidden'); // Ensure GM selector is visible for new sandbox game
                ui.modeTitle.textContent = "Dynamic Narrative Setup"; // Reset title

                populateGmSelector(); // Repopulate GM selector if needed and set default
            };

            // Function to populate GM selector
            async function populateGmSelector() {
                ui.gmSelector.innerHTML = ''; // Clear previous options
                // Filter only 'gm' role personas
                const gmPersonas = dynamicGameState.personas.filter(p => p.role === 'gm');
                gmPersonas.forEach(persona => {
                    const option = document.createElement('option');
                    option.value = persona.actor_id;
                    option.textContent = persona.name;
                    ui.gmSelector.appendChild(option);
                });
                // Select 'The Conductor' by default for Sandbox, or first available if 'The Conductor' not present
                ui.gmSelector.value = 'The_Conductor';
                if (!ui.gmSelector.value && gmPersonas.length > 0) { // If Conductor not found, pick first
                    ui.gmSelector.value = gmPersonas[0].actor_id;
                }
                // CORRECTED LINE: Use dynamicGameState.personas.find()
                ui.selectedGmDisplay.textContent = dynamicGameState.personas.find(p => p.actor_id === ui.gmSelector.value)?.name || "No Director Selected";
            }


            // Main initialization function for UI and data
            async function initializeUIAndData() {
                buildCreationAndGameUI(); // Build the core UI structure first

                try {
                    const personasData = await fetchAPI('/api/personas');
                    dynamicGameState.personas = personasData; // Cache personas
                    populateGmSelector(); // Populate GM selector on init
                } catch (e) {
                    const startButton = document.getElementById('start-btn-rpg');
                    if (startButton) {
                        startButton.disabled = true;
                        startButton.textContent = 'CONNECTION FAILED';
                    }
                    console.error("Initialization failed:", e);
                }
                
                // Attach event listener to the SANDBOX launch button (renamed)
                launchSandboxBtn.addEventListener('click', () => {
                    hubScreen.classList.remove('active');
                    creationScreen.classList.add('active');
                    
                    // Configure creation screen for sandbox
                    ui.opponentSideNameFormGroup.classList.add('hidden');
                    ui.initialOpponentSidePromptFormGroup.classList.add('hidden');
                    ui.initialPlayerSideLabel.textContent = "Your Side's Opening Strategy & Composition:";
                    
                    ui.gmSelectionGroup.classList.remove('hidden'); // Show GM selection for sandbox
                    ui.gmSelector.value = 'The_Conductor'; // Default for sandbox
                    // CORRECTED LINE: Use dynamicGameState.personas.find()
                    ui.selectedGmDisplay.textContent = dynamicGameState.personas.find(p => p.actor_id === ui.gmSelector.value)?.name || "The Conductor"; // Display initial selection
                    
                    ui.modeTitle.textContent = "Sandbox Narrative Setup"; // Update title
                    ui.startBtn.onclick = prepareSandboxChronicle; // Assign directly to prevent multiple listeners
                    
                    // Clear fields
                    ui.playerSideNameInput.value = '';
                    ui.prompt.value = '';
                    ui.initialPlayerSidePrompt.value = '';
                });

                // Attach event listener to the COMPETITIVE launch button
                launchCompetitiveBtn.addEventListener('click', () => {
                    hubScreen.classList.remove('active');
                    creationScreen.classList.add('active');

                    // Configure creation screen for competitive
                    ui.opponentSideNameFormGroup.classList.remove('hidden');
                    ui.initialOpponentSidePromptFormGroup.classList.remove('hidden');
                    ui.initialPlayerSideLabel.textContent = "Your Side's Opening Strategy & Composition:";

                    ui.gmSelectionGroup.classList.add('hidden'); // Hide GM selection for competitive
                    ui.selectedGmDisplay.textContent = "The Grand Tactician (Fixed)"; // Show fixed GM
                    
                    ui.modeTitle.textContent = "Competitive Narrative Setup"; // Update title
                    ui.startBtn.onclick = prepareCompetitiveChronicle; // Assign directly

                    // Clear fields
                    ui.playerSideNameInput.value = '';
                    ui.opponentSideNameInput.value = '';
                    ui.prompt.value = '';
                    ui.initialPlayerSidePrompt.value = '';
                    ui.initialOpponentSidePrompt.value = '';
                });

                // GM Selector Change Listener
                // CORRECTED LINE: Use dynamicGameState.personas.find()
                ui.gmSelector.addEventListener('change', () => {
                    ui.selectedGmDisplay.textContent = dynamicGameState.personas.find(p => p.actor_id === ui.gmSelector.value)?.name || "No Director Selected";
                });

                // STT: Mic button listeners
                micBtnRpg.addEventListener('mousedown', handleMicPress);
                micBtnRpg.addEventListener('mouseup', handleMicRelease);
                // Save button listener
                saveBtnRpg.addEventListener('click', saveAdventure);
                // NEW: New Game button listener
                newGameBtn.addEventListener('click', startNewGame);
                // NEW: Initiate Combat button listener
                initiateCombatBtn.addEventListener('click', async () => {
                    if (!sandboxOpponentDescriptionInput.value.trim()) {
                        alert("Please describe who/what you want to fight.");
                        return;
                    }

                    setLoading(true, `Preparing for combat with ${sandboxOpponentDescriptionInput.value.trim()}...`);
                    try {
                        const data = await fetchAPI(`/api/dynamic-narrative/${dynamicGameState.currentSceneId}/initiate-sandbox-combat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ opponentDescription: sandboxOpponentDescriptionInput.value.trim() })
                        });

                        dynamicGameState.gameMode = data.gameMode; // Should now be 'sandbox_combat'
                        dynamicGameState.currentRound = data.currentRound;
                        dynamicGameState.playerHP = data.playerHP;
                        dynamicGameState.opponentHP = data.opponentHP;
                        dynamicGameState.sandboxOpponentName = data.sandboxOpponentName; // Store the opponent name

                        setLoading(false);
                        const textDisplayPromise = addLog(data.response.narration, dynamicGameState.personas.find(p => p.actor_id === data.character)?.name || 'Director');
                        const audioPlayPromise = new Promise(resolve => {
                            setTimeout(async () => {
                                await playAudio(data.response.audio_base_64);
                                resolve();
                            }, 1500);
                        });
                        await Promise.all([textDisplayPromise, audioPlayPromise]);

                        toggleCompetitiveInputOverlay(true); // Re-show input overlay
                        dynamicGameState.turnPhase = 'player_side_input';
                        updateInputState(); // Will now show combat UI (player input enabled, opponent input disabled)
                        sandboxOpponentDescriptionInput.value = ''; // Clear description field
                    } catch (e) {
                        console.error("Failed to initiate sandbox combat:", e);
                        setLoading(false);
                    }
                });


                // Combined Submit Button Listener (for both textareas)
                submitTurnBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    if (dynamicGameState.gameOver) {
                        addLog("The chronicle has concluded. Start a new game.", "System", "system-info");
                        return;
                    }

                    const playerMessage = userInputPlayerSide.value.trim();
                    const opponentMessage = userInputOpponentSide.value.trim(); // Will be empty for sandbox/sandbox_combat

                    // Validate input based on game mode
                    if (!playerMessage) {
                        alert("Please describe actions for your side.");
                        return;
                    }
                    if (dynamicGameState.gameMode === 'competitive' && !opponentMessage) {
                         alert("Please describe actions for the opponent side in competitive mode.");
                         return;
                    }

                    processTurnInput({ message: playerMessage });
                });


                // Click anywhere on screen to bring up input overlay
                document.body.addEventListener('click', (e) => { 
                    if (competitiveInputOverlay.classList.contains('hidden') && dynamicGameState.currentSceneId && 
                        dynamicGameState.turnPhase === 'player_side_input' && !competitiveInputOverlay.contains(e.target) && !dynamicGameState.gameOver) {
                        toggleCompetitiveInputOverlay(true);
                    }
                });

                // STT: Global keyboard shortcuts for game screen (adjusted for gameMode)
                document.addEventListener('keydown', (e) => {
                    if (genesisScreen.classList.contains('active') && e.code === 'Space' && !isHoldingSpace &&
                        document.activeElement.tagName !== 'TEXTAREA' && document.activeElement.tagName !== 'INPUT' &&
                        dynamicGameState.turnPhase === 'player_side_input' && !dynamicGameState.gameOver &&
                        (dynamicGameState.gameMode === 'sandbox' || dynamicGameState.gameMode === 'sandbox_combat')) { // Only for sandbox related modes
                        e.preventDefault();
                        isHoldingSpace = true;
                        spacebarTimer = setTimeout(() => {
                            handleMicPress();
                            toggleCompetitiveInputOverlay(false);
                        }, 250);
                    }
                });

                document.addEventListener('keyup', (e) => {
                    if (genesisScreen.classList.contains('active') && e.code === 'Space' && isHoldingSpace) {
                        clearTimeout(spacebarTimer);
                        if (dynamicGameState.isListening) {
                            handleMicRelease();
                        } else {
                            if (!dynamicGameState.gameOver) {
                                toggleCompetitiveInputOverlay(true);
                            }
                        }
                        isHoldingSpace = false;
                    }
                });

                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Escape' && !competitiveInputOverlay.classList.contains('hidden')) {
                        if (dynamicGameState.turnPhase !== 'adjudicating' && !dynamicGameState.gameOver) {
                            toggleCompetitiveInputOverlay(false);
                        }
                    }
                });
            }

            // Initial UI setup on page load
            initializeUIAndData();
        });
    </script>
</body>
</html>